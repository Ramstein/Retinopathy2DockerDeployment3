import base64
import os


def decode_archive(archive_name, content):
    with open(archive_name, "wb") as f:
        f.write(base64.b64decode(content))


decode_archive('pytorch_toolbelt-0.1.3.tar.gz',
               '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')
os.system('pip install pytorch_toolbelt-0.1.3.tar.gz')

# Imports
import os
import math
import cv2
import torch
import pandas as pd
import numpy as np
import multiprocessing
import albumentations as A
from tqdm import tqdm
from torch.utils.data import Dataset
from torch import nn
from functools import partial
from pytorch_toolbelt.utils import fs
from pytorch_toolbelt.utils.torch_utils import to_numpy
from torch.utils.data import DataLoader
from pytorch_toolbelt.inference.tta import *
from pytorch_toolbelt.modules.encoders import *
from pytorch_toolbelt.modules.pooling import *
from pytorch_toolbelt.modules.scse import *
import torch.nn.functional as F
from pytorch_toolbelt.modules import ABN
from torchvision.models import densenet169, densenet121, densenet201
import torch.utils.model_zoo as model_zoo
from multiprocessing.pool import Pool
from collections import OrderedDict, defaultdict
from albumentations.augmentations.functional import longest_max_size
import pytorch_toolbelt.inference.functional as FF
from pytorch_toolbelt.modules.backbone.efficient_net import efficient_net_b0, efficient_net_b1, efficient_net_b2, \
    efficient_net_b3, efficient_net_b4, efficient_net_b5, efficient_net_b6, efficient_net_b7
from pytorch_toolbelt.modules.encoders import EfficientNetEncoder
from typing import List
from skimage.measure import label
from skimage.morphology import remove_small_objects
from pytorch_toolbelt.modules.decoders import FPNDecoder
from pytorch_toolbelt.modules.fpn import FPNBottleneckBlockBN
from pytorch_toolbelt.modules.hypercolumn import HyperColumn
from pytorch_toolbelt.modules.coord_conv import AddCoords, append_coords
from sklearn import metrics
import scipy as sp
from scipy.stats import trim_mean

UNLABELED_CLASS = -100
pretrained_settings = None
pretrained_settings_dilated = None


# Functions


def tensor_from_rgb_image(image: np.ndarray) -> torch.Tensor:
    image = np.moveaxis(image, -1, 0)
    image = np.ascontiguousarray(image)
    image = torch.from_numpy(image)
    return image


def id_from_fname(fname: str):
    return os.path.splitext(os.path.basename(fname))[0]


def read_rgb_image(fname: str) -> np.ndarray:
    """Read RGB image from filesystem. This function uses PIL to load image since PIL respects EXIF image orientation flag.
    :param fname: Image file path
    :return: A numpy array with a loaded image in RGB format
    """
    from PIL import Image
    im = Image.open(fname)
    if im.mode != 'RGB':
        im = im.convert('RGB')
    image = np.asarray(im)
    return image


def get_class_names(coarse_grading=False):
    if coarse_grading:
        return [
            'No DR',
            'DR (Mild/Moderate/Severe)',
            'Proliferative DR'
        ]

    CLASS_NAMES = [
        'No DR',
        'Mild',
        'Moderate',
        'Severe',
        'Proliferative DR'
    ]
    return CLASS_NAMES


class RetinopathyDataset(Dataset):
    def __init__(self, images, targets,
                 transform: A.Compose,
                 target_as_array=False,
                 dtype=int,
                 meta_features=False):
        if targets is not None:
            targets = np.array(targets)
            unique_targets = set(targets)
            if len(unique_targets.difference({0, 1, 2, 3, 4, UNLABELED_CLASS})):
                raise ValueError('Unexpected targets in Y ' + str(unique_targets))

        self.meta_features = meta_features
        self.images = np.array(images)
        self.targets = targets
        self.transform = transform
        self.target_as_array = target_as_array
        self.dtype = dtype

    def __len__(self):
        return len(self.images)

    def __getitem__(self, item):
        image = cv2.imread(self.images[item])  # Read with OpenCV instead PIL. It's faster
        if image is None:
            raise FileNotFoundError(self.images[item])
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        height, width = image.shape[:2]
        diagnosis = UNLABELED_CLASS
        if self.targets is not None:
            diagnosis = self.targets[item]

        data = self.transform(image=image, diagnosis=diagnosis)
        diagnosis = data['diagnosis']
        data = {'image': tensor_from_rgb_image(data['image']),
                'image_id': id_from_fname(self.images[item])}

        if self.meta_features:
            log_height = math.log(height)
            log_width = math.log(width)
            aspect_ratio = log_height / log_width
            mean = np.mean(image, axis=(0, 1))

            meta_features = np.array([
                log_height,
                log_width,
                aspect_ratio,
                mean[0],
                mean[1],
                mean[2]
            ])
            data['meta_features'] = meta_features

        diagnosis = self.dtype(diagnosis)
        if self.target_as_array:
            data['targets'] = np.array([diagnosis])
        else:
            data['targets'] = diagnosis

        return data


class RMSPool2d(nn.Module):
    """
    Root mean square pooling
    """

    def __init__(self, eps=1e-9):
        super().__init__()
        self.eps = eps
        self.avg_pool = GlobalAvgPool2d()

    def forward(self, x):
        x_mean = torch.mean(x, dim=[2, 3], keepdim=True)
        avg_pool = self.avg_pool((x - x_mean) ** 2)
        return (avg_pool + self.eps).sqrt()


class DenseNet121Encoder(EncoderModule):
    def __init__(self, pretrained=True):
        densenet = densenet121(pretrained=pretrained)
        super().__init__([1024], [32], [0])
        self.features = densenet.features

    def forward(self, x):
        x = self.features(x)
        x = F.relu(x, inplace=True)
        return [x]


class DenseNet169Encoder(EncoderModule):
    def __init__(self, pretrained=True):
        densenet = densenet169(pretrained=pretrained)
        super().__init__([1664], [32], [0])
        self.features = densenet.features

    def forward(self, x):
        x = self.features(x)
        x = F.relu(x, inplace=True)
        return [x]


class DenseNet201Encoder(EncoderModule):
    def __init__(self, pretrained=True):
        densenet = densenet201(pretrained=pretrained)
        super().__init__([1920], [32], [0])
        self.features = densenet.features

    def forward(self, x):
        x = self.features(x)
        x = F.relu(x, inplace=True)
        return [x]


def drop_connect(inputs, p, training):
    """
    Drop connect implementation.
    """
    if not training:
        return inputs
    batch_size = inputs.shape[0]
    keep_prob = 1 - p
    random_tensor = keep_prob
    random_tensor += torch.rand([batch_size, 1, 1, 1],
                                dtype=inputs.dtype, device=inputs.device)  # uniform [0,1)
    binary_tensor = torch.floor(random_tensor)
    output = (inputs / keep_prob) * binary_tensor
    return output


def initialize_pretrained_model_dilated(model, num_classes, settings):
    assert num_classes == settings['num_classes'], \
        'num_classes should be {}, but is {}'.format(
            settings['num_classes'], num_classes)
    model.load_state_dict(model_zoo.load_url(settings['url']))
    model.input_space = settings['input_space']
    model.input_size = settings['input_size']
    model.input_range = settings['input_range']
    model.mean = settings['mean']
    model.std = settings['std']


class SEModule(nn.Module):

    def __init__(self, channels, reduction):
        super(SEModule, self).__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.fc1 = nn.Conv2d(channels, channels // reduction, kernel_size=1,
                             padding=0)
        self.relu = nn.ReLU(inplace=True)
        self.fc2 = nn.Conv2d(channels // reduction, channels, kernel_size=1,
                             padding=0)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        module_input = x
        x = self.avg_pool(x)
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        x = self.sigmoid(x)
        return module_input * x


class BottleneckD(nn.Module):
    """
    Base class for bottlenecks that implements `forward()` method.
    """

    def __init__(self, drop_connect_rate=0.):
        super().__init__()
        self.drop_connect_rate = drop_connect_rate

    def forward(self, x):
        residual = x

        out = self.conv1(x)
        out = self.bn1(out)
        out = self.relu(out)

        out = self.conv2(out)
        out = self.bn2(out)
        out = self.relu(out)

        out = self.conv3(out)
        out = self.bn3(out)

        if self.downsample is not None:
            residual = self.downsample(x)

        out = self.se_module(out)
        if self.drop_connect_rate:
            out = drop_connect(out, p=self.drop_connect_rate,
                               training=self.training)

        out = out + residual
        out = self.relu(out)

        return out


class SEBottleneckD(BottleneckD):
    """
    Bottleneck for SENet154.
    """

    expansion = 4

    def __init__(self, inplanes, planes, groups, reduction, stride=1,
                 downsample=None, dilation=1, drop_connect_rate=0.):
        super(SEBottleneckD, self).__init__(drop_connect_rate)
        self.conv1 = nn.Conv2d(inplanes, planes * 2, kernel_size=1, bias=False)
        self.bn1 = nn.BatchNorm2d(planes * 2)
        self.conv2 = nn.Conv2d(planes * 2, planes * 4, kernel_size=3,
                               stride=stride, padding=dilation, groups=groups,
                               bias=False, dilation=dilation)
        self.bn2 = nn.BatchNorm2d(planes * 4)
        self.conv3 = nn.Conv2d(planes * 4, planes * 4, kernel_size=1,
                               bias=False)
        self.bn3 = nn.BatchNorm2d(planes * 4)
        self.relu = nn.ReLU(inplace=True)
        self.se_module = SEModule(planes * 4, reduction=reduction)
        self.downsample = downsample
        self.stride = stride


class SEResNetBottleneckD(BottleneckD):
    """
    ResNet bottleneck with a Squeeze-and-Excitation module. It follows Caffe
    implementation and uses `stride=stride` in `conv1` and not in `conv2`
    (the latter is used in the torchvision implementation of ResNet).
    """

    expansion = 4

    def __init__(self, inplanes, planes, groups, reduction, stride=1,
                 downsample=None, dilation=1, drop_connect_rate=0.):
        super(SEResNetBottleneckD, self).__init__(drop_connect_rate)
        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, bias=False,
                               stride=stride)
        self.bn1 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, padding=dilation,
                               groups=groups, bias=False, dilation=dilation)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False)
        self.bn3 = nn.BatchNorm2d(planes * 4)
        self.relu = nn.ReLU(inplace=True)
        self.se_module = SEModule(planes * 4, reduction=reduction)
        self.downsample = downsample
        self.stride = stride


class SEResNeXtBottleneckD(BottleneckD):
    """
    ResNeXt bottleneck type C with a Squeeze-and-Excitation module.
    """

    expansion = 4

    def __init__(self, inplanes, planes, groups, reduction, stride=1,
                 downsample=None, base_width=4, dilation=1, drop_connect_rate=0.):
        super(SEResNeXtBottleneckD, self).__init__(drop_connect_rate)
        width = math.floor(planes * (base_width / 64)) * groups
        self.conv1 = nn.Conv2d(inplanes, width, kernel_size=1, bias=False,
                               stride=1)
        self.bn1 = nn.BatchNorm2d(width)
        self.conv2 = nn.Conv2d(width, width, kernel_size=3, stride=stride, padding=dilation,
                               groups=groups, bias=False, dilation=dilation)
        self.bn2 = nn.BatchNorm2d(width)
        self.conv3 = nn.Conv2d(width, planes * 4, kernel_size=1, bias=False)
        self.bn3 = nn.BatchNorm2d(planes * 4)
        self.relu = nn.ReLU(inplace=True)
        self.se_module = SEModule(planes * 4, reduction=reduction)
        self.downsample = downsample
        self.stride = stride


class SENetD(nn.Module):

    def __init__(self, block, layers, groups, reduction, dropout_p=0.1,
                 inplanes=128, input_3x3=True, dilation=(1, 1, 2, 4), downsample_kernel_size=3,
                 downsample_padding=1, num_classes=1000):
        """
        Parameters
        ----------
        block (nn.Module): Bottleneck class.
            - For SENet154: SEBottleneck
            - For SE-ResNet models: SEResNetBottleneck
            - For SE-ResNeXt models:  SEResNeXtBottleneck
        layers (list of ints): Number of residual blocks for 4 layers of the
            network (layer1...layer4).
        groups (int): Number of groups for the 3x3 convolution in each
            bottleneck block.
            - For SENet154: 64
            - For SE-ResNet models: 1
            - For SE-ResNeXt models:  32
        reduction (int): Reduction ratio for Squeeze-and-Excitation modules.
            - For all models: 16
        dropout_p (float or None): Drop probability for the Dropout layer.
            If `None` the Dropout layer is not used.
            - For SENet154: 0.2
            - For SE-ResNet models: None
            - For SE-ResNeXt models: None
        inplanes (int):  Number of input channels for layer1.
            - For SENet154: 128
            - For SE-ResNet models: 64
            - For SE-ResNeXt models: 64
        input_3x3 (bool): If `True`, use three 3x3 convolutions instead of
            a single 7x7 convolution in layer0.
            - For SENet154: True
            - For SE-ResNet models: False
            - For SE-ResNeXt models: False
        downsample_kernel_size (int): Kernel size for downsampling convolutions
            in layer2, layer3 and layer4.
            - For SENet154: 3
            - For SE-ResNet models: 1
            - For SE-ResNeXt models: 1
        downsample_padding (int): Padding for downsampling convolutions in
            layer2, layer3 and layer4.
            - For SENet154: 1
            - For SE-ResNet models: 0
            - For SE-ResNeXt models: 0
        num_classes (int): Number of outputs in `last_linear` layer.
            - For all models: 1000
        """
        super(SENetD, self).__init__()
        self.inplanes = inplanes
        if input_3x3:
            layer0_modules = [
                ('conv1', nn.Conv2d(3, 64, 3, stride=2, padding=1,
                                    bias=False)),
                ('bn1', nn.BatchNorm2d(64)),
                ('relu1', nn.ReLU(inplace=True)),
                ('conv2', nn.Conv2d(64, 64, 3, stride=1, padding=1,
                                    bias=False)),
                ('bn2', nn.BatchNorm2d(64)),
                ('relu2', nn.ReLU(inplace=True)),
                ('conv3', nn.Conv2d(64, inplanes, 3, stride=1, padding=1,
                                    bias=False)),
                ('bn3', nn.BatchNorm2d(inplanes)),
                ('relu3', nn.ReLU(inplace=True)),
            ]
        else:
            layer0_modules = [
                ('conv1', nn.Conv2d(3, inplanes, kernel_size=7, stride=2,
                                    padding=3, bias=False)),
                ('bn1', nn.BatchNorm2d(inplanes)),
                ('relu1', nn.ReLU(inplace=True)),
            ]
        # To preserve compatibility with Caffe weights `ceil_mode=True`
        # is used instead of `padding=1`.
        layer0_modules.append(('pool', nn.MaxPool2d(3, stride=2,
                                                    ceil_mode=True)))
        self.layer0 = nn.Sequential(OrderedDict(layer0_modules))
        self.layer1 = self._make_layer(
            block,
            planes=64,
            blocks=layers[0],
            groups=groups,
            reduction=reduction,
            downsample_kernel_size=1,
            downsample_padding=0,
            drop_connect_rate=dropout_p,
            dilation=dilation[0]
        )
        self.layer2 = self._make_layer(
            block,
            planes=128,
            blocks=layers[1],
            stride=2,
            groups=groups,
            reduction=reduction,
            downsample_kernel_size=downsample_kernel_size,
            downsample_padding=downsample_padding,
            drop_connect_rate=dropout_p,
            dilation=dilation[1]
        )
        self.layer3 = self._make_layer(
            block,
            planes=256,
            blocks=layers[2],
            stride=2,
            groups=groups,
            reduction=reduction,
            downsample_kernel_size=downsample_kernel_size,
            downsample_padding=downsample_padding,
            drop_connect_rate=dropout_p,
            dilation=dilation[2]
        )
        self.layer4 = self._make_layer(
            block,
            planes=512,
            blocks=layers[3],
            stride=2,
            groups=groups,
            reduction=reduction,
            downsample_kernel_size=downsample_kernel_size,
            downsample_padding=downsample_padding,
            drop_connect_rate=dropout_p,
            dilation=dilation[3]
        )
        self.avg_pool = nn.AvgPool2d(7, stride=1)
        self.dropout = nn.Dropout(dropout_p) if dropout_p is not None else None
        self.last_linear = nn.Linear(512 * block.expansion, num_classes)

    def _make_layer(self, block, planes, blocks, groups, reduction, stride=1,
                    downsample_kernel_size=1, downsample_padding=0, dilation=1, drop_connect_rate=0.):
        downsample = None
        if stride != 1 or self.inplanes != planes * block.expansion:
            downsample = nn.Sequential(
                nn.Conv2d(self.inplanes, planes * block.expansion,
                          kernel_size=downsample_kernel_size, stride=stride,
                          padding=downsample_padding, bias=False),
                nn.BatchNorm2d(planes * block.expansion),
            )

        layers = []
        layers.append(block(self.inplanes, planes, groups, reduction, stride,
                            downsample))
        self.inplanes = planes * block.expansion
        for i in range(1, blocks):
            d = dilation
            if i == blocks - 1:
                d = 1  # Do not apply dillation on last block
            layers.append(block(self.inplanes, planes, groups, reduction,
                                dilation=d, drop_connect_rate=drop_connect_rate))

        return nn.Sequential(*layers)

    def features(self, x):
        x = self.layer0(x)
        x = self.layer1(x)
        x = self.layer2(x)
        x = self.layer3(x)
        x = self.layer4(x)
        return x

    def logits(self, x):
        x = self.avg_pool(x)
        if self.dropout is not None:
            x = self.dropout(x)
        x = x.view(x.size(0), -1)
        x = self.last_linear(x)
        return x

    def forward(self, x):
        x = self.features(x)
        x = self.logits(x)
        return x


def dilated_se_resnext50_32x4d(num_classes=1000, pretrained='imagenet', dilation=(1, 1, 2, 4), dropout_p=0.1):
    model = SENetD(SEResNeXtBottleneckD, [3, 4, 6, 3], groups=32, reduction=16, dilation=dilation,
                   dropout_p=dropout_p, inplanes=64, input_3x3=False,
                   downsample_kernel_size=1, downsample_padding=0,
                   num_classes=num_classes)
    if pretrained is not None:
        settings = pretrained_settings_dilated['se_resnext50_32x4d'][pretrained]
        initialize_pretrained_model_dilated(model, num_classes, settings)
    return model


class DilatedSEResNeXt50Encoder(SEResnetEncoder):
    def __init__(self, pretrained=True, layers=[1, 2, 3, 4], dropout=0.):
        encoder = dilated_se_resnext50_32x4d(pretrained='imagenet' if pretrained else None, dropout_p=dropout)
        super().__init__(encoder, [64, 256, 512, 1024, 2048], [2, 4, 8, 16, 32], layers)


def dilated_se_resnext101_32x4d(num_classes=1000, pretrained='imagenet', dilation=(1, 1, 2, 4), dropout_p=0.1):
    model = SENetD(SEResNeXtBottleneckD, [3, 4, 23, 3], groups=32, reduction=16, dilation=dilation,
                   dropout_p=dropout_p, inplanes=64, input_3x3=False,
                   downsample_kernel_size=1, downsample_padding=0,
                   num_classes=num_classes)
    if pretrained is not None:
        settings = pretrained_settings_dilated['se_resnext101_32x4d'][pretrained]
        initialize_pretrained_model_dilated(model, num_classes, settings)
    return model


class DilatedSEResNeXt101Encoder(SEResnetEncoder):
    def __init__(self, pretrained=True, layers=[1, 2, 3, 4], dropout=0.):
        encoder = dilated_se_resnext101_32x4d(pretrained='imagenet' if pretrained else None,
                                              dilation=(1, 1, 4, 8),
                                              dropout_p=dropout)
        super().__init__(encoder, [64, 256, 512, 1024, 2048], [2, 4, 8, 16, 32], layers)


class GlobalWeightedAvgPoolHead(nn.Module):
    """
    1) Squeeze last feature map in num_classes
    2) Compute global average
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.gwap = GWAP(self.features_size)
        self.dropout = nn.Dropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)

        # Regression to grade using SSD-like module
        self.regression = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 1),
            nn.ELU(inplace=True),
        )

        self.ordinal = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, num_classes - 1),
        )

    def forward(self, feature_maps):
        # Take last feature map
        features = feature_maps[-1]
        features = self.gwap(features)
        features = features.view(features.size(0), features.size(1))
        features = self.dropout(features)

        logits = self.logits(features)

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class GlobalAvgPoolHead(nn.Module):
    """
    1) Squeeze last feature map in num_classes
    2) Compute global average
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.dropout = nn.Dropout(dropout)
        self.bottleneck = nn.Conv2d(self.features_size, num_classes, kernel_size=1)

        # Regression to grade using SSD-like module
        self.regression = nn.Sequential(
            GlobalAvgPool2d(),
            Flatten(),
            nn.Linear(self.features_size, 64),
            nn.ReLU(inplace=True),
            nn.Linear(64, 16),
            nn.ReLU(inplace=True),
            nn.Linear(16, 1),
            nn.ReLU6()
        )

        self.ordinal = nn.Sequential(
            GlobalAvgPool2d(),
            Flatten(),
            nn.Linear(self.features_size, 64),
            nn.LeakyReLU(inplace=True),
            nn.Linear(64, num_classes - 1))

    def forward(self, feature_maps):
        # Take last feature map
        features = feature_maps[-1]

        features = self.dropout(features)

        # Squeeze to num_classes
        logits = self.bottleneck(features)
        # Compute average
        logits = F.adaptive_avg_pool2d(logits, output_size=1)
        # Flatten
        logits = logits.view(logits.size(0), logits.size(1))

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        return {
            'features': features.mean(dim=(2, 3)),
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class BasicConv2d(nn.Module):

    def __init__(self, in_planes, out_planes, kernel_size, stride, padding=0):
        super(BasicConv2d, self).__init__()
        self.conv = nn.Conv2d(in_planes, out_planes,
                              kernel_size=kernel_size, stride=stride,
                              padding=padding, bias=False)  # verify bias false
        self.bn = nn.BatchNorm2d(out_planes,
                                 eps=0.001,  # value found in tensorflow
                                 momentum=0.1,  # default pytorch value
                                 affine=True)
        self.relu = nn.ReLU(inplace=True)

    def forward(self, x):
        x = self.conv(x)
        x = self.bn(x)
        x = self.relu(x)
        return x


class Mixed_3a(nn.Module):

    def __init__(self):
        super(Mixed_3a, self).__init__()
        self.maxpool = nn.MaxPool2d(3, stride=2)
        self.conv = BasicConv2d(64, 96, kernel_size=3, stride=2)

    def forward(self, x):
        x0 = self.maxpool(x)
        x1 = self.conv(x)
        out = torch.cat((x0, x1), 1)
        return out


class Mixed_4a(nn.Module):

    def __init__(self):
        super(Mixed_4a, self).__init__()

        self.branch0 = nn.Sequential(
            BasicConv2d(160, 64, kernel_size=1, stride=1),
            BasicConv2d(64, 96, kernel_size=3, stride=1)
        )

        self.branch1 = nn.Sequential(
            BasicConv2d(160, 64, kernel_size=1, stride=1),
            BasicConv2d(64, 64, kernel_size=(1, 7), stride=1, padding=(0, 3)),
            BasicConv2d(64, 64, kernel_size=(7, 1), stride=1, padding=(3, 0)),
            BasicConv2d(64, 96, kernel_size=(3, 3), stride=1)
        )

    def forward(self, x):
        x0 = self.branch0(x)
        x1 = self.branch1(x)
        out = torch.cat((x0, x1), 1)
        return out


class Mixed_5a(nn.Module):

    def __init__(self):
        super(Mixed_5a, self).__init__()
        self.conv = BasicConv2d(192, 192, kernel_size=3, stride=2)
        self.maxpool = nn.MaxPool2d(3, stride=2)

    def forward(self, x):
        x0 = self.conv(x)
        x1 = self.maxpool(x)
        out = torch.cat((x0, x1), 1)
        return out


class Reduction_A(nn.Module):

    def __init__(self):
        super(Reduction_A, self).__init__()
        self.branch0 = BasicConv2d(384, 384, kernel_size=3, stride=2)

        self.branch1 = nn.Sequential(
            BasicConv2d(384, 192, kernel_size=1, stride=1),
            BasicConv2d(192, 224, kernel_size=3, stride=1, padding=1),
            BasicConv2d(224, 256, kernel_size=3, stride=2)
        )

        self.branch2 = nn.MaxPool2d(3, stride=2)

    def forward(self, x):
        x0 = self.branch0(x)
        x1 = self.branch1(x)
        x2 = self.branch2(x)
        out = torch.cat((x0, x1, x2), 1)
        return out


class Inception_A(nn.Module):

    def __init__(self):
        super(Inception_A, self).__init__()
        self.branch0 = BasicConv2d(384, 96, kernel_size=1, stride=1)

        self.branch1 = nn.Sequential(
            BasicConv2d(384, 64, kernel_size=1, stride=1),
            BasicConv2d(64, 96, kernel_size=3, stride=1, padding=1)
        )

        self.branch2 = nn.Sequential(
            BasicConv2d(384, 64, kernel_size=1, stride=1),
            BasicConv2d(64, 96, kernel_size=3, stride=1, padding=1),
            BasicConv2d(96, 96, kernel_size=3, stride=1, padding=1)
        )

        self.branch3 = nn.Sequential(
            nn.AvgPool2d(3, stride=1, padding=1, count_include_pad=False),
            BasicConv2d(384, 96, kernel_size=1, stride=1)
        )

    def forward(self, x):
        x0 = self.branch0(x)
        x1 = self.branch1(x)
        x2 = self.branch2(x)
        x3 = self.branch3(x)
        out = torch.cat((x0, x1, x2, x3), 1)
        return out


class Inception_B(nn.Module):

    def __init__(self):
        super(Inception_B, self).__init__()
        self.branch0 = BasicConv2d(1024, 384, kernel_size=1, stride=1)

        self.branch1 = nn.Sequential(
            BasicConv2d(1024, 192, kernel_size=1, stride=1),
            BasicConv2d(192, 224, kernel_size=(1, 7), stride=1, padding=(0, 3)),
            BasicConv2d(224, 256, kernel_size=(7, 1), stride=1, padding=(3, 0))
        )

        self.branch2 = nn.Sequential(
            BasicConv2d(1024, 192, kernel_size=1, stride=1),
            BasicConv2d(192, 192, kernel_size=(7, 1), stride=1, padding=(3, 0)),
            BasicConv2d(192, 224, kernel_size=(1, 7), stride=1, padding=(0, 3)),
            BasicConv2d(224, 224, kernel_size=(7, 1), stride=1, padding=(3, 0)),
            BasicConv2d(224, 256, kernel_size=(1, 7), stride=1, padding=(0, 3))
        )

        self.branch3 = nn.Sequential(
            nn.AvgPool2d(3, stride=1, padding=1, count_include_pad=False),
            BasicConv2d(1024, 128, kernel_size=1, stride=1)
        )

    def forward(self, x):
        x0 = self.branch0(x)
        x1 = self.branch1(x)
        x2 = self.branch2(x)
        x3 = self.branch3(x)
        out = torch.cat((x0, x1, x2, x3), 1)
        return out


class Reduction_B(nn.Module):

    def __init__(self):
        super(Reduction_B, self).__init__()

        self.branch0 = nn.Sequential(
            BasicConv2d(1024, 192, kernel_size=1, stride=1),
            BasicConv2d(192, 192, kernel_size=3, stride=2)
        )

        self.branch1 = nn.Sequential(
            BasicConv2d(1024, 256, kernel_size=1, stride=1),
            BasicConv2d(256, 256, kernel_size=(1, 7), stride=1, padding=(0, 3)),
            BasicConv2d(256, 320, kernel_size=(7, 1), stride=1, padding=(3, 0)),
            BasicConv2d(320, 320, kernel_size=3, stride=2)
        )

        self.branch2 = nn.MaxPool2d(3, stride=2)

    def forward(self, x):
        x0 = self.branch0(x)
        x1 = self.branch1(x)
        x2 = self.branch2(x)
        out = torch.cat((x0, x1, x2), 1)
        return out


class Inception_C(nn.Module):

    def __init__(self):
        super(Inception_C, self).__init__()

        self.branch0 = BasicConv2d(1536, 256, kernel_size=1, stride=1)

        self.branch1_0 = BasicConv2d(1536, 384, kernel_size=1, stride=1)
        self.branch1_1a = BasicConv2d(384, 256, kernel_size=(1, 3), stride=1, padding=(0, 1))
        self.branch1_1b = BasicConv2d(384, 256, kernel_size=(3, 1), stride=1, padding=(1, 0))

        self.branch2_0 = BasicConv2d(1536, 384, kernel_size=1, stride=1)
        self.branch2_1 = BasicConv2d(384, 448, kernel_size=(3, 1), stride=1, padding=(1, 0))
        self.branch2_2 = BasicConv2d(448, 512, kernel_size=(1, 3), stride=1, padding=(0, 1))
        self.branch2_3a = BasicConv2d(512, 256, kernel_size=(1, 3), stride=1, padding=(0, 1))
        self.branch2_3b = BasicConv2d(512, 256, kernel_size=(3, 1), stride=1, padding=(1, 0))

        self.branch3 = nn.Sequential(
            nn.AvgPool2d(3, stride=1, padding=1, count_include_pad=False),
            BasicConv2d(1536, 256, kernel_size=1, stride=1)
        )

    def forward(self, x):
        x0 = self.branch0(x)

        x1_0 = self.branch1_0(x)
        x1_1a = self.branch1_1a(x1_0)
        x1_1b = self.branch1_1b(x1_0)
        x1 = torch.cat((x1_1a, x1_1b), 1)

        x2_0 = self.branch2_0(x)
        x2_1 = self.branch2_1(x2_0)
        x2_2 = self.branch2_2(x2_1)
        x2_3a = self.branch2_3a(x2_2)
        x2_3b = self.branch2_3b(x2_2)
        x2 = torch.cat((x2_3a, x2_3b), 1)

        x3 = self.branch3(x)

        out = torch.cat((x0, x1, x2, x3), 1)
        return out


class InceptionV4(nn.Module):

    def __init__(self, num_classes=1001):
        super(InceptionV4, self).__init__()
        # Special attributs
        self.input_space = None
        self.input_size = (299, 299, 3)
        self.mean = None
        self.std = None
        # Modules
        self.features = nn.Sequential(
            BasicConv2d(3, 32, kernel_size=3, stride=2),
            BasicConv2d(32, 32, kernel_size=3, stride=1),
            BasicConv2d(32, 64, kernel_size=3, stride=1, padding=1),
            Mixed_3a(),
            Mixed_4a(),
            Mixed_5a(),
            Inception_A(),
            Inception_A(),
            Inception_A(),
            Inception_A(),
            Reduction_A(),  # Mixed_6a
            Inception_B(),
            Inception_B(),
            Inception_B(),
            Inception_B(),
            Inception_B(),
            Inception_B(),
            Inception_B(),
            Reduction_B(),  # Mixed_7a
            Inception_C(),
            Inception_C(),
            Inception_C()
        )
        self.last_linear = nn.Linear(1536, num_classes)

    def logits(self, features):
        # Allows image of any size to be processed
        adaptiveAvgPoolWidth = features.shape[2]
        x = F.avg_pool2d(features, kernel_size=adaptiveAvgPoolWidth)
        x = x.view(x.size(0), -1)
        x = self.last_linear(x)
        return x

    def forward(self, input):
        x = self.features(input)
        x = self.logits(x)
        return x


def inceptionv4(num_classes=1000, pretrained='imagenet'):
    if pretrained:
        settings = pretrained_settings['inceptionv4'][pretrained]
        assert num_classes == settings['num_classes'], \
            "num_classes should be {}, but is {}".format(settings['num_classes'], num_classes)

        # both 'imagenet'&'imagenet+background' are loaded from same parameters
        model = InceptionV4(num_classes=1001)
        model.load_state_dict(model_zoo.load_url(settings['url']))

        if pretrained == 'imagenet':
            new_last_linear = nn.Linear(1536, 1000)
            new_last_linear.weight.data = model.last_linear.weight.data[1:]
            new_last_linear.bias.data = model.last_linear.bias.data[1:]
            model.last_linear = new_last_linear

        model.input_space = settings['input_space']
        model.input_size = settings['input_size']
        model.input_range = settings['input_range']
        model.mean = settings['mean']
        model.std = settings['std']
    else:
        model = InceptionV4(num_classes=num_classes)
    return model


class InceptionV4Encoder(EncoderModule):
    def __init__(self, pretrained=True):
        inception = inceptionv4(pretrained='imagenet' if pretrained else None)
        super().__init__([1536], [32], [0])
        self.features = inception.features

    def forward(self, x):
        x = self.features(x)
        return [x]


class LSTMBottleneck(nn.Module):
    def __init__(self, in_channels, hidden_size, dropout=0.1, num_layers=2):
        super().__init__()
        self.lstm = nn.LSTM(input_size=in_channels + 3,
                            hidden_size=hidden_size,
                            num_layers=num_layers,
                            dropout=dropout,
                            batch_first=True,
                            bidirectional=True)

    def forward(self, input):
        input = append_coords(input, with_r=True)

        batch_size = input.size(0)
        in_channels = input.size(1)
        rows = input.size(2)
        cols = input.size(3)
        input = input.permute((0, 3, 1, 2)).reshape(batch_size, -1, in_channels)

        self.lstm.flatten_parameters()

        lstm_out, hidden = self.lstm(input)
        lstm_out = lstm_out.view(batch_size, rows * cols, 2, -1)  # (batch, seq_len, num_directions, hidden_size)

        lstm_left = lstm_out[:, :, 0, :]
        lstm_right = lstm_out[:, :, 1, :]
        lstm_out = lstm_left + lstm_right
        last_out = lstm_out[:, -1, :]  # Many to one
        return last_out


class EfficientNetB0ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b0(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [16, 24, 40, 80, 112, 192, 320],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB1ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b1(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [16, 24, 40, 80, 112, 192, 320],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB2ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b2(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [16, 24, 48, 88, 120, 208, 352],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB3ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b3(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [24, 32, 48, 96, 136, 232, 384],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB4ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b4(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [24, 32, 56, 112, 160, 272, 448],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB5ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b5(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [24, 40, 64, 128, 176, 304, 512],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB6ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b6(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [32, 40, 72, 144, 200, 344, 576],
                         [2, 4, 8, 16, 16, 32, 32], layers)


class EfficientNetB7ReLUEncoder(EfficientNetEncoder):
    def __init__(self, activation='leaky_relu', layers=[1, 2, 4, 6], abn_block=ABN, pretrained=False):
        abn_params = {
            'activation': activation,
            'momentum': 0.1,
            'eps': 1e-5
        }
        super().__init__(efficient_net_b7(num_classes=1, abn_block=abn_block, abn_params=abn_params),
                         [32, 48, 80, 160, 224, 384, 640],
                         [2, 4, 8, 16, 16, 32, 32], layers)


def pnasnet5large(num_classes=1001, pretrained='imagenet'):
    r"""PNASNet-5 model architecture from the
    `"Progressive Neural Architecture Search"
    <https://arxiv.org/abs/1712.00559>`_ paper.
    """
    if pretrained:
        settings = pretrained_settings['pnasnet5large'][pretrained]
        assert num_classes == settings[
            'num_classes'], 'num_classes should be {}, but is {}'.format(
            settings['num_classes'], num_classes)

        # both 'imagenet'&'imagenet+background' are loaded from same parameters
        model = PNASNet5Large(num_classes=1001)
        model.load_state_dict(model_zoo.load_url(settings['url']))

        if pretrained == 'imagenet':
            new_last_linear = nn.Linear(model.last_linear.in_features, 1000)
            new_last_linear.weight.data = model.last_linear.weight.data[1:]
            new_last_linear.bias.data = model.last_linear.bias.data[1:]
            model.last_linear = new_last_linear

        model.input_space = settings['input_space']
        model.input_size = settings['input_size']
        model.input_range = settings['input_range']

        model.mean = settings['mean']
        model.std = settings['std']
    else:
        model = PNASNet5Large(num_classes=num_classes)
    return model


class CoordDoubleConvBNRelu(nn.Module):
    def __init__(self, in_dec_filters: int, out_filters: int, abn_block=ABN):
        super().__init__()
        self.add_coords = AddCoords(with_r=True)

        self.conv1 = nn.Conv2d(in_dec_filters + 3, out_filters, kernel_size=3, padding=1, stride=1, bias=False)
        self.abn1 = abn_block(out_filters)

        self.conv2 = nn.Conv2d(out_filters + 3, out_filters, kernel_size=3, padding=1, stride=1, bias=False)
        self.abn2 = abn_block(out_filters)

    def forward(self, x):
        x = self.add_coords(x)
        x = self.conv1(x)
        x = self.abn1(x)

        x = self.add_coords(x)
        x = self.conv2(x)
        x = self.abn2(x)
        return x


class PNasnet5LargeEncoder(EncoderModule):
    def __init__(self, pretrained=False):
        model = pnasnet5large(pretrained='imagenet+background' if pretrained else None)
        super().__init__([4320], [32], [0])
        model.last_linear = None  # Remove last linear block as we have our own
        self.extractor = model

    def forward(self, x):
        x = F.relu(self.extractor.features(x))
        return [x]


class FlipLRMultiheadTTA(nn.Module):
    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, image):
        output = self.model(image)

        # Flip image input
        output2 = self.model(FF.torch_fliplr(image))

        if len(output['features'].size()) == 4:
            output2['features'] = FF.torch_fliplr(output2['features'])

        output['logits'] = (output['logits'] + output2['logits']) * 0.5
        output['ordinal'] = (output['ordinal'] + output2['ordinal']) * 0.5
        output['regression'] = (output['regression'] + output2['regression']) * 0.5
        output['features'] = (output['features'] + output2['features']) * 0.5
        return output


class Flip4MultiheadTTA(nn.Module):
    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, image):
        outputs = []
        outputs.append(self.model(image))

        image_fliplr = FF.torch_fliplr(image)
        outputs.append(self.model(image_fliplr))

        image_flipud = FF.torch_flipud(image)
        outputs.append(self.model(image_flipud))

        image_fliplr_ud = FF.torch_fliplr(image_flipud)
        outputs.append(self.model(FF.torch_fliplr(image_fliplr_ud)))

        for key in {'logits', 'features', 'regression', 'ordinal'}:
            for i in range(1, len(outputs)):
                outputs[0][key] += outputs[i][key]

            outputs[0][key] /= len(outputs)

        return outputs[0]


class MultiscaleFlipLRMultiheadTTA(nn.Module):
    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, image):
        rows = image.size(2)
        cols = image.size(3)
        outputs = []
        for scale in [1.0, 1.15, 0.87]:
            image_i = F.interpolate(image, size=(int(rows * scale), int(cols * scale)), mode='bilinear',
                                    align_corners=True)

            output = self.model(image_i)
            outputs.append(output)

            # Flip image input
            output2 = self.model(FF.torch_fliplr(image_i))
            outputs.append(output2)

        for key in {'logits', 'features', 'regression', 'ordinal'}:
            for i in range(1, len(outputs)):
                outputs[0][key] += outputs[i][key]
            outputs[0][key] /= len(outputs)

        return outputs[0]


class ApplySoftmaxToLogits(nn.Module):
    def __init__(self):
        super().__init__()

    def forward(self, input):
        input['logits'] = input['logits'].softmax(dim=1)
        return input


class OrdinalEncoderHeadModel(nn.Module):
    def __init__(self, encoder: EncoderModule, head, num_classes):
        super().__init__()
        self.encoder = encoder
        self.head = head
        self.link = LogisticCumulativeLink(num_classes,
                                           init_cutpoints='ordered')

    @property
    def features_size(self):
        return self.head.features_size

    def forward(self, input):
        feature_maps = self.encoder(input)
        features, logits = self.head(feature_maps)
        logits = self.link(logits)
        return {'features': features, 'logits': logits}


class GlobalRankPooling(nn.Module):
    def __init__(self, num_features, spatial_size):
        super().__init__()
        self.conv = nn.Conv1d(num_features, num_features, spatial_size, groups=num_features)

    def forward(self, x: torch.Tensor):
        spatial_size = x.size(2) * x.size(3)
        assert spatial_size == self.conv.kernel_size[0], f'Expected spatial size {self.conv.kernel_size[0]}, ' \
                                                         f'got {x.size(2)}x{x.size(3)}'

        x = x.view(x.size(0), x.size(1), -1)  # Flatten spatial dimensions
        x_sorted, index = x.topk(spatial_size, dim=2)

        x = self.conv(x_sorted)  # [B, C, 1]
        return x.squeeze(2)


class GlobalAvgPoolHeadV2(nn.Module):
    """
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.avgpool = GlobalAvgPool2d()
        self.dropout = nn.Dropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)
        self.regression = nn.Linear(self.features_size, 1)
        self.ordinal = nn.Linear(self.features_size, num_classes - 1)

    def forward(self, feature_maps):
        # Take last feature map
        features = self.avgpool(feature_maps[-1])
        features = features.view(features.size(0), features.size(1))
        features = self.dropout(features)

        # Squeeze to num_classes
        logits = self.logits(features)
        regression = (self.regression(features) + 2.).log()
        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class GlobalMaxPoolHeadV2(nn.Module):
    """
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.maxpool = GlobalMaxPool2d()
        self.dropout = nn.Dropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)
        self.regression = nn.Sequential(nn.Linear(self.features_size, self.features_size // 4),
                                        nn.BatchNorm1d(self.features_size // 4),
                                        nn.ReLU(inplace=True),
                                        nn.Linear(self.features_size // 4, self.features_size // 8),
                                        nn.BatchNorm1d(self.features_size // 8),
                                        nn.ReLU(inplace=True),
                                        nn.Linear(self.features_size // 8, 1))

        self.ordinal = nn.Sequential(nn.Linear(self.features_size, self.features_size // 4),
                                     nn.BatchNorm1d(self.features_size // 4),
                                     nn.ReLU(inplace=True),
                                     nn.Linear(self.features_size // 4, self.features_size // 8),
                                     nn.BatchNorm1d(self.features_size // 8),
                                     nn.ReLU(inplace=True),
                                     nn.Linear(self.features_size // 8, num_classes - 1))

    def forward(self, feature_maps):
        # Take last feature map
        features = self.maxpool(feature_maps[-1])
        features = features.view(features.size(0), features.size(1))
        features = self.dropout(features)

        # Squeeze to num_classes
        logits = self.logits(features)
        regression = self.regression(features)
        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class RankPoolingHeadModel(nn.Module):
    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.rank_pool = GlobalRankPooling(self.features_size, 16 * 16)
        self.dropout = nn.AlphaDropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)

        # Regression to grade using SSD-like module
        self.regression = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 1)
        )

        self.ordinal = nn.Linear(self.features_size, num_classes - 1)

    def forward(self, features):
        features = self.rank_pool(features[-1])
        features = self.dropout(features)
        logits = self.logits(features)

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class RankPoolingHeadModelV2(nn.Module):
    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = 512
        self.bottleneck = nn.Conv2d(feature_maps[-1], self.features_size, kernel_size=1)
        self.rank_pool = GlobalRankPooling(self.features_size, 16 * 16)
        self.dropout = nn.AlphaDropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)

        # Regression to grade using SSD-like module
        self.regression = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 1)
        )

        self.ordinal = nn.Linear(self.features_size, num_classes - 1)

    def forward(self, features):
        features = self.bottleneck(self.dropout(features[-1]))
        features = self.rank_pool(features)

        logits = self.logits(features)

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class LogisticCumulativeLink(nn.Module):
    """
    Converts a single number to the proportional odds of belonging to a class.
    Parameters
    ----------
    num_classes : int
        Number of ordered classes to partition the odds into.
    init_cutpoints : str (default='ordered')
        How to initialize the cutpoints of the model. Valid values are
        - ordered : cutpoints are initialized to halfway between each class.
        - random : cutpoints are initialized with random values.
    """

    def __init__(self, num_classes: int,
                 init_cutpoints: str = 'ordered') -> None:
        assert num_classes > 2, (
            'Only use this model if you have 3 or more classes'
        )
        super().__init__()
        self.num_classes = num_classes
        self.init_cutpoints = init_cutpoints
        if init_cutpoints == 'ordered':
            num_cutpoints = self.num_classes - 1
            cutpoints = torch.arange(num_cutpoints).float() - num_cutpoints / 2
            self.cutpoints = nn.Parameter(cutpoints)
        elif init_cutpoints == 'random':
            cutpoints = torch.rand(self.num_classes - 1).sort()[0]
            self.cutpoints = nn.Parameter(cutpoints)
        else:
            raise ValueError(f'{init_cutpoints} is not a valid init_cutpoints '
                             f'type')

    def forward(self, X: torch.Tensor) -> torch.Tensor:
        """
        Equation (11) from
        "On the consistency of ordinal regression methods", Pedregosa et. al.
        """
        sigmoids = torch.sigmoid(self.cutpoints - X)
        link_mat = sigmoids[:, 1:] - sigmoids[:, :-1]
        link_mat = torch.cat((
            sigmoids[:, [0]],
            link_mat,
            (1 - sigmoids[:, [-1]])
        ),
            dim=1
        )
        return link_mat


class RMSPoolHead(nn.Module):
    """
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1]
        self.rms_pooling = RMSPool2d(self.features_size)
        self.dropout = nn.Dropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)

        self.regression = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 1),
        )

        self.ordinal = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, num_classes - 1),
        )

    def forward(self, feature_maps):
        # Take last feature map
        features = feature_maps[-1]
        features = self.rms_pooling(features)
        features = features.view(features.size(0), features.size(1))
        features = self.dropout(features)

        logits = self.logits(features)
        regression = self.regression(features)
        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class RNNHead(nn.Module):
    def __init__(self, feature_maps, num_classes: int, dropout=0.):
        super().__init__()
        self.features_size = feature_maps[-1] // 8
        self.rnn_pool = LSTMBottleneck(feature_maps[-1] + 3, self.features_size, dropout=dropout)

        self.logits = nn.Linear(self.features_size, num_classes)

        self.regression = nn.Sequential(
            nn.Linear(self.features_size, self.features_size),
            nn.LeakyReLU(inplace=True),
            nn.Linear(self.features_size, self.features_size),
            nn.LeakyReLU(inplace=True),
            nn.Linear(self.features_size, 1),
        )

        self.ordinal = nn.Sequential(
            nn.Linear(self.features_size, self.features_size),
            nn.LeakyReLU(inplace=True),
            nn.Linear(self.features_size, num_classes - 1),
            nn.Sigmoid())

    def forward(self, feature_maps):
        # Take last feature map
        features = feature_maps[-1]
        features = append_coords(features, with_r=True)
        features = self.rnn_pool(features)

        # Squeeze to num_classes
        logits = self.logits(features)
        regression = self.regression(features)
        ordinal = self.ordinal(features).sum(dim=1)

        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class GlobalMaxPoolHead(nn.Module):
    """
    1) Squeeze last feature map in num_classes
    2) Compute global average
    """

    def __init__(self, feature_maps, num_classes: int, dropout=0., reduction=8):
        super().__init__()
        self.features_size = feature_maps[-1] // reduction
        self.bottleneck = nn.Sequential(
            nn.Conv2d(feature_maps[-1], self.features_size, kernel_size=1, bias=False),
            nn.BatchNorm2d(self.features_size),
            nn.ReLU(inplace=True))

        self.maxpool = GlobalMaxPool2d()
        self.dropout = nn.Dropout(dropout)
        self.logits = nn.Linear(self.features_size, num_classes)

        # Regression to grade using SSD-like module
        self.regression = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 1),
            nn.ELU(inplace=True),
        )

        self.ordinal = nn.Sequential(
            nn.Linear(self.features_size, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, 16),
            nn.ELU(inplace=True),
            nn.Linear(16, num_classes - 1),
        )

    def forward(self, feature_maps):
        # Take last feature map
        features = feature_maps[-1]
        features = self.bottleneck(features)
        features = self.maxpool(features)
        features = features.view(features.size(0), features.size(1))
        features = self.dropout(features)

        logits = self.logits(features)

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sigmoid().sum(dim=1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class FPNHeadModel(nn.Module):
    def __init__(self, feature_maps, num_classes: int, dropout=0., reduction=8):
        super().__init__()
        self.decoder = FPNDecoder(features=feature_maps[1:],
                                  bottleneck=FPNBottleneckBlockBN,
                                  prediction_block=CoordDoubleConvBNRelu,
                                  fpn_features=128,
                                  prediction_features=128)

        self.hypercolumn = HyperColumn(mode='nearest', align_corners=None)
        self.maxpool = GlobalMaxPool2d()
        self.features_size = sum(self.decoder.output_filters)
        self.logits = nn.Linear(self.features_size, num_classes)
        self.dropout = nn.Dropout(dropout)

        self.logits = nn.Linear(self.features_size, num_classes)
        self.regression = nn.Sequential(nn.Linear(self.features_size, self.features_size // 4),
                                        nn.BatchNorm1d(self.features_size // 4),
                                        nn.ReLU(inplace=True),
                                        nn.Linear(self.features_size // 4, self.features_size // 8),
                                        nn.BatchNorm1d(self.features_size // 8),
                                        nn.ReLU(inplace=True),
                                        nn.Linear(self.features_size // 8, 1))

        self.ordinal = nn.Sequential(nn.Linear(self.features_size, self.features_size),
                                     nn.BatchNorm1d(self.features_size),
                                     nn.LeakyReLU(inplace=True),
                                     nn.Linear(self.features_size, self.features_size),
                                     nn.BatchNorm1d(self.features_size),
                                     nn.LeakyReLU(inplace=True),
                                     nn.Linear(self.features_size, num_classes - 1),
                                     nn.Sigmoid())

    def forward(self, features):
        features = self.decoder(features[1:])
        features = self.hypercolumn(*features)
        features = self.maxpool(features)
        features = features.view(features.size(0), features.size(1))

        features = self.dropout(features)

        logits = self.logits(features)

        regression = self.regression(features)
        if regression.size(1) == 1:
            regression = regression.squeeze(1)

        ordinal = self.ordinal(features).sum(dim=1)

        return {
            'features': features,
            'logits': logits,
            'regression': regression,
            'ordinal': ordinal
        }


class Flatten(nn.Module):
    def __init__(self):
        super().__init__()

    def forward(self, x):
        return x.view(x.shape[0], -1)


class EncoderHeadModel(nn.Module):
    def __init__(self, encoder: EncoderModule, head: nn.Module):
        super().__init__()
        self.encoder = encoder
        self.head = head

    @property
    def features_size(self):
        return self.head.features_size

    def forward(self, image):
        feature_maps = self.encoder(image)
        result = self.head(feature_maps)
        return result


def crop_black(image, tolerance=5):
    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    cv2.threshold(gray, tolerance, 255, type=cv2.THRESH_BINARY, dst=gray)
    # cv2.threshold(gray, tolerance, 255, type=cv2.THRESH_BINARY | cv2.THRESH_OTSU, dst=gray)
    cv2.medianBlur(gray, 7, gray)

    # Remove small objects that occupy less than 5% of an image
    min_size = 0.05 * int(image.shape[0] * image.shape[1])
    label_image = label(gray)
    label_image = remove_small_objects(label_image, min_size=min_size)
    gray = (label_image > 0).astype(np.uint8)

    x, y, w, h = cv2.boundingRect(gray)

    # Sanity check for very dark images
    non_black_area = w * h
    image_area = image.shape[0] * image.shape[1]
    fg_ratio = non_black_area / image_area

    # If area of black region is more than half of the whole image area,
    # we do not crop it.
    if fg_ratio < 0.5:
        return image

    return image[y:y + h, x:x + w]


class CropBlackRegions(A.ImageOnlyTransform):
    def __init__(self, tolerance=5, p=1.):
        super().__init__(p=p)
        self.tolerance = tolerance

    def apply(self, img, **params):
        return crop_black(img, self.tolerance)

    def get_transform_init_args_names(self):
        return ('tolerance',)


def unsharp_mask(image, sigmaX=10):
    image = cv2.addWeighted(image, 4, cv2.GaussianBlur(image, (0, 0), sigmaX), -4, 128)
    return image


class UnsharpMask(A.ImageOnlyTransform):
    def __init__(self, p=1.0):
        super().__init__(p=p)

    def apply(self, img, **params):
        return unsharp_mask(img)

    def get_transform_init_args_names(self):
        return tuple()


def clahe_preprocessing(image, clip_limit=4.0, tile_grid_size=(18, 18)):
    image_norm = image.copy()

    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=tile_grid_size)
    image_norm[:, :, 0] = clahe.apply(image[:, :, 0])
    image_norm[:, :, 1] = clahe.apply(image[:, :, 1])
    image_norm[:, :, 2] = clahe.apply(image[:, :, 2])

    # image_norm = cv2.addWeighted(image, 0.5, image_norm, 0.5, 0)
    return image_norm


class ChannelIndependentCLAHE(A.ImageOnlyTransform):
    def __init__(self, p=1.0):
        super().__init__(p=p)

    def apply(self, img, **params):
        return clahe_preprocessing(img)

    def get_transform_init_args_names(self):
        return tuple()


def unsharp_mask_v2(image):
    filter = cv2.bilateralFilter(image,
                                 d=32,
                                 sigmaColor=75,
                                 sigmaSpace=15)

    multiplier = 6
    difference = cv2.addWeighted(image, multiplier, filter, -multiplier, 0, dtype=cv2.CV_32F)
    a_max = np.max(difference)
    a_min = np.min(difference)
    rng = max(a_max, -a_min, 1)
    scale = 127. / rng
    difference = difference * scale + 127
    difference = difference.astype(np.uint8)
    return difference


class UnsharpMaskV2(A.ImageOnlyTransform):
    def __init__(self, p=1.0):
        super().__init__(p=p)

    def apply(self, img, **params):
        return unsharp_mask_v3(img)

    def get_transform_init_args_names(self):
        return tuple()


class RedFree(A.ImageOnlyTransform):
    def __init__(self, p=1):
        super().__init__(p=p)

    def apply(self, img, **params):
        return red_free(img)


def red_free(image):
    """
    https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4944099/
    The red-free version of this photo shows the new vessels at the optic disc more clearly.
    Altering the images, e.g. by using red-free, is a valuable tool for detecting retinopathy
    :param image:
    :return:
    """
    image = image.copy()
    image[..., 0] = 0
    return image


def get_model(model_name, num_classes, pretrained=True, dropout=0.0, **kwargs):
    keys = model_name.split('_')
    if len(keys) == 2:
        encoder_name, head_name = keys
        model = 'baseline'
    else:
        model, encoder_name, head_name = keys

    abn_block = ABN
    try:
        from inplace_abn import InPlaceABN
        abn_block = InPlaceABN
        print('Using InPlaceABN')
    except:
        print('InplaceABN not available, using classic BatchNorm+Act')

    ENCODERS = {
        'resnet18': Resnet18Encoder,
        'resnet34': Resnet34Encoder,
        'resnet50': Resnet50Encoder,
        'resnet101': Resnet101Encoder,
        'resnet152': Resnet152Encoder,
        'seresnext50': SEResNeXt50Encoder,
        'seresnext50d': partial(DilatedSEResNeXt50Encoder, dropout=0.25),
        'seresnext101': SEResNeXt101Encoder,
        'seresnext101d': partial(DilatedSEResNeXt101Encoder, dropout=0.25),
        'seresnet152': SEResnet152Encoder,
        'senet154': SENet154Encoder,
        'densenet121': DenseNet121Encoder,
        'densenet169': DenseNet169Encoder,
        'densenet201': DenseNet201Encoder,
        'inceptionv4': InceptionV4Encoder,
        'efficientb0': partial(EfficientNetB0ReLUEncoder, abn_block=abn_block),
        'efficientb1': partial(EfficientNetB1ReLUEncoder, abn_block=abn_block),
        'efficientb2': partial(EfficientNetB2ReLUEncoder, abn_block=abn_block),
        'efficientb3': partial(EfficientNetB3ReLUEncoder, abn_block=abn_block),
        'efficientb4': partial(EfficientNetB4ReLUEncoder, abn_block=abn_block),
        'efficientb5': partial(EfficientNetB5ReLUEncoder, abn_block=abn_block),
        'efficientb6': partial(EfficientNetB6ReLUEncoder, abn_block=abn_block),
        'efficientb7': partial(EfficientNetB7ReLUEncoder, abn_block=abn_block),
        'pnasnet5': PNasnet5LargeEncoder
    }

    encoder = ENCODERS[encoder_name](pretrained=pretrained)

    HEADS = {
        'gap': GlobalAvgPoolHead,
        'gapv2': GlobalAvgPoolHeadV2,
        'gwap': GlobalWeightedAvgPoolHead,
        'rms': RMSPoolHead,
        'max': GlobalMaxPoolHead,
        'maxv2': GlobalMaxPoolHeadV2,
        'fpn': FPNHeadModel,
        'rank': RankPoolingHeadModel,
        'rankv2': RankPoolingHeadModelV2,
        'rnn': RNNHead
    }

    MODELS = {
        'baseline': EncoderHeadModel,
    }

    head = HEADS[head_name](feature_maps=encoder.output_filters, num_classes=num_classes, dropout=dropout)

    model = MODELS[model](encoder, head)
    return model


def get_preprocessing_transform(preprocessing: str) -> A.ImageOnlyTransform:
    assert preprocessing in {None, 'unsharp', 'unsharpv2', 'iclahe', 'clahe', 'redfree'}

    if preprocessing is None:
        return A.NoOp()

    if preprocessing == 'unsharp':
        return UnsharpMask(p=1)

    if preprocessing == 'unsharpv2':
        return UnsharpMaskV2(p=1)

    if preprocessing == 'iclahe':
        return ChannelIndependentCLAHE(p=1)

    if preprocessing == 'clahe':
        return A.CLAHE(p=1)

    if preprocessing == 'redfree':
        return RedFree(p=1)

    raise KeyError(f'Unsupported preprocessing method {preprocessing}')


def get_test_transform(image_size, preprocessing: str = None, crop_black=True):
    longest_size = max(image_size[0], image_size[1])
    return A.Compose([
        CropBlackRegions(tolerance=5) if crop_black else A.NoOp(always_apply=True),
        A.LongestMaxSize(longest_size, interpolation=cv2.INTER_CUBIC),

        A.PadIfNeeded(image_size[0], image_size[1],
                      border_mode=cv2.BORDER_CONSTANT, value=0),

        get_preprocessing_transform(preprocessing),
        A.Normalize()
    ])


def preprocess(image_fname, output_dir, image_size=768):
    image = cv2.imread(image_fname)
    image = crop_black(image, tolerance=5)
    image = longest_max_size(image, max_size=image_size, interpolation=cv2.INTER_CUBIC)

    image_id = fs.id_from_fname(image_fname)
    dst_fname = os.path.join(output_dir, image_id + '.png')
    cv2.imwrite(dst_fname, image)
    return


def convert_dir(input_dir, output_dir, image_size=768, workers=32):
    os.makedirs(output_dir, exist_ok=True)
    images = fs.find_images_in_dir(input_dir)

    processing_fn = partial(preprocess, output_dir=output_dir, image_size=image_size)

    with Pool(workers) as wp:
        for image_id in tqdm(wp.imap_unordered(processing_fn, images), total=len(images)):
            pass


def report_checkpoint(checkpoint):
    print('Epoch          :', checkpoint['epoch'])
    print('Metrics (Train):', checkpoint['epoch_metrics']['train'])
    print('Metrics (Valid):', checkpoint['epoch_metrics']['valid'])


@torch.no_grad()
def run_models_inference_via_dataset(model_checkpoints: List[str],
                                     dataset: RetinopathyDataset,
                                     batch_size=1,
                                     coarse_grading=False,
                                     tta=None,
                                     need_features=True,
                                     apply_softmax=True,
                                     workers=None) -> List[pd.DataFrame]:
    if workers is None:
        workers = multiprocessing.cpu_count()

    models = []
    models_predictions = []

    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

    # Load models
    for model_checkpoint in model_checkpoints:
        checkpoint = torch.load(model_checkpoint)

        model_name = checkpoint['checkpoint_data']['cmd_args']['model']

        print(model_checkpoint, model_name)
        report_checkpoint(checkpoint)

        num_classes = len(get_class_names(coarse_grading=coarse_grading))
        model = get_model(model_name, pretrained=False, num_classes=num_classes)
        model.load_state_dict(checkpoint['model_state_dict'], strict=True)
        del checkpoint

        if apply_softmax:
            model = nn.Sequential(model, ApplySoftmaxToLogits())

        if tta == 'flip' or tta == 'fliplr':
            model = FlipLRMultiheadTTA(model)

        if tta == 'flip4':
            model = Flip4MultiheadTTA(model)

        if tta == 'fliplr_ms':
            model = MultiscaleFlipLRMultiheadTTA(model)

        model = model.cuda()
        if torch.cuda.device_count() > 1:
            model = nn.DataParallel(model, device_ids=[id for id in range(torch.cuda.device_count())])
        model = model.eval()

        models.append(model)
        models_predictions.append(defaultdict(list))

    data_loader = DataLoader(dataset, batch_size,
                             pin_memory=True,
                             num_workers=workers)

    for batch in tqdm(data_loader):
        input = batch['image'].cuda(non_blocking=True)

        for model, predictions in zip(models, models_predictions):
            outputs = model(input)

            predictions['image_id'].extend(batch['image_id'])
            if 'targets' in batch:
                predictions['diagnosis'].extend(to_numpy(batch['targets']).tolist())

            predictions['logits'].extend(to_numpy(outputs['logits']).tolist())
            predictions['regression'].extend(to_numpy(outputs['regression']).tolist())
            predictions['ordinal'].extend(to_numpy(outputs['ordinal']).tolist())
            if need_features:
                predictions['features'].extend(to_numpy(outputs['features']).tolist())

    models_predictions = [pd.DataFrame.from_dict(p) for p in models_predictions]

    del data_loader, models
    return models_predictions


def run_models_inference(model_checkpoints: List[str],
                         test_csv: pd.DataFrame,
                         data_dir,
                         images_dir='test_images',
                         preprocessing=None,
                         image_size=None,
                         crop_black=True,
                         **kwargs) -> List[pd.DataFrame]:
    checkpoint = torch.load(model_checkpoints[0])
    if preprocessing is None:
        preprocessing = checkpoint['checkpoint_data']['cmd_args'].get('preprocessing', None)

    if image_size is None:
        image_size = checkpoint['checkpoint_data']['cmd_args'].get('image_size', 512)
        image_size = (image_size, image_size)

    image_fnames = test_csv['id_code'].apply(lambda x: image_with_name_in_dir(os.path.join(data_dir, images_dir), x))

    if 'diagnosis' in test_csv:
        targets = test_csv['diagnosis'].values
    else:
        targets = None

    test_ds = RetinopathyDataset(image_fnames, targets, get_test_transform(image_size,
                                                                           preprocessing=preprocessing,
                                                                           crop_black=crop_black))
    return run_models_inference_via_dataset(model_checkpoints, test_ds, **kwargs)


def average_predictions(predictions: List[pd.DataFrame], column: str,
                        method='mean', min=None, max=None) -> pd.DataFrame:
    preds = []
    for p in predictions:
        pred = to_numpy(p[column].values.tolist())
        preds.append(pred)

    preds = np.row_stack(preds)
    if min is not None or max is not None:
        preds = np.clip(preds, min, max)

    if method == 'mean':
        y_pred = np.mean(preds, axis=0)
    elif method == 'trim_mean':
        y_pred = trim_mean(preds, proportiontocut=0.1, axis=0)
    elif method == 'median':
        y_pred = np.median(preds, axis=0)
    else:
        raise KeyError(method)

    result = pd.DataFrame.from_dict({'id_code': predictions[0]['image_id'].values,
                                     'diagnosis': y_pred.tolist()})
    return result


def cls_predictions_to_submission(predictions) -> pd.DataFrame:
    predictions = predictions.copy()
    predictions['diagnosis'] = predictions['diagnosis'].apply(lambda x: np.argmax(x))
    return predictions


def reg_predictions_to_submission(predictions, rounding_coefficients=None) -> pd.DataFrame:
    rounder = partial(regression_to_class, rounding_coefficients=rounding_coefficients)
    predictions = predictions.copy()
    predictions['diagnosis'] = rounder(predictions['diagnosis'].values)
    predictions['diagnosis'] = predictions['diagnosis'].apply(int)
    return predictions


def regression_to_class(value: torch.Tensor, min=0, max=4, rounding_coefficients=None):
    if isinstance(value, np.ndarray):
        value = torch.from_numpy(value)
    if isinstance(value, (int, float)):
        value = torch.tensor(value)

    if rounding_coefficients is None:
        value = torch.round(value)
        value = torch.clamp(value, min, max)
    else:
        rounded = torch.zeros(len(value))
        rounded[value < rounding_coefficients[0]] = 0
        rounded[(value >= rounding_coefficients[0]) & (value < rounding_coefficients[1])] = 1
        rounded[(value >= rounding_coefficients[1]) & (value < rounding_coefficients[2])] = 2
        rounded[(value >= rounding_coefficients[2]) & (value < rounding_coefficients[3])] = 3
        rounded[value >= rounding_coefficients[3]] = 4
        value = rounded.long()
    return value.long()


def image_with_name_in_dir(dirname, image_id):
    for ext in ['png', 'jpg', 'jpeg', 'tif']:
        image_fname = os.path.join(dirname, f'{image_id}.{ext}')
        if os.path.isfile(image_fname):
            return image_fname
    raise FileNotFoundError(image_fname)


class OptimizedRounder(object):
    def __init__(self):
        self.coef_ = 0

    def _kappa_loss(self, coef, X, y):
        X_p = np.copy(X)
        for i, pred in enumerate(X_p):
            if pred < coef[0]:
                X_p[i] = 0
            elif pred >= coef[0] and pred < coef[1]:
                X_p[i] = 1
            elif pred >= coef[1] and pred < coef[2]:
                X_p[i] = 2
            elif pred >= coef[2] and pred < coef[3]:
                X_p[i] = 3
            else:
                X_p[i] = 4

        ll = metrics.cohen_kappa_score(y, X_p, weights='quadratic')
        return -ll

    def fit(self, X, y):
        loss_partial = partial(self._kappa_loss, X=X, y=y)
        initial_coef = [0.5, 1.5, 2.5, 3.5]
        self.coef_ = sp.optimize.minimize(loss_partial, initial_coef, method='nelder-mead')
        return self.coefficients()

    def predict(self, X, coef):
        X_p = np.copy(X)
        for i, pred in enumerate(X_p):
            if pred < coef[0]:
                X_p[i] = 0
            elif pred >= coef[0] and pred < coef[1]:
                X_p[i] = 1
            elif pred >= coef[1] and pred < coef[2]:
                X_p[i] = 2
            elif pred >= coef[2] and pred < coef[3]:
                X_p[i] = 3
            else:
                X_p[i] = 4
        return X_p

    def coefficients(self):
        return self.coef_['x']
